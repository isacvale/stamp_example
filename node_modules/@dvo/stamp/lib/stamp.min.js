"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var stampData = {};
var aliasData = {};

var identity = x => x;

function StampData(selector, context) {
  this.selector = selector;
  this.template = context.querySelector(selector);
  this.target = this.template.parentElement;
  this.cap = Infinity;
  this.keep = 0;
  this.mutator = identity;
  this.context = context;
}

function createNewStamp(selector, context) {
  stampData[selector] = new StampData(selector, context);
}

function Stamp(selector) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var data = {
    context: config.context || document
  };

  function count() {
    var query = "[data-_stamp=\"".concat(data.selector, "\"]");
    return data.target.querySelectorAll(query).length;
  }

  function deleteElements(list) {
    list.forEach((el, idx) => {
      if (idx >= data.keep) {
        el.parentElement.removeChild(el);
      }
    });
  }

  var api = {
    get(selector) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = config.context || document;
      var override = config.override || false;
      var originalSelector = aliasData[selector] ? aliasData[selector] : selector;

      if (!stampData[originalSelector] || override || config.context) {
        createNewStamp(originalSelector, context);
      }

      data = stampData[originalSelector];
      return this;
    },

    stamp(callback) {
      if (count() < data.cap) {
        var target = data.target;
        var clone = data.template.content.cloneNode(true);
        var cloneContent = clone.firstElementChild;
        data.mutator(cloneContent);
        cloneContent.setAttribute('data-_stamp', data.selector);
        target.append(clone);

        if (callback) {
          var appendedElement = target.lastElementChild;
          var tag = appendedElement.tagName.toLowerCase();

          if (tag.includes('-')) {
            customElements.whenDefined(tag).then(() => callback(appendedElement));
          } else {
            callback(appendedElement);
          }
        }
      }

      return this;
    },

    alias(alias) {
      aliasData[alias] = data.selector;
      return this;
    },

    change(mutator) {
      data.mutator = mutator;
      return this;
    },

    target(targetSelector) {
      data.target = data.context.querySelector(targetSelector);
      return this;
    },

    context() {
      var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
      data.context = element;
      return this;
    },

    keep(keepAmount) {
      data.keep = keepAmount;
      return this;
    },

    cap(capAmount) {
      data.cap = capAmount;
      return this;
    },

    clear() {
      var query = "[data-_stamp=\"".concat(data.selector, "\"]");
      var stamps = data.target.querySelectorAll(query);
      deleteElements(stamps);
      return this;
    },

    clearAll() {
      var children = Array.from(data.target.children).filter(el => el.tagName !== 'TEMPLATE');
      deleteElements(children);
      return this;
    },

    execute(func) {
      func(this);
      return this;
    },

    debug() {
      var returnResult = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!returnResult) console.debug('stamp data:', data);
      return returnResult ? data : this;
    }

  };
  if (selector) api.get(selector, config);
  return api;
}

var _default = Stamp;
exports.default = _default;